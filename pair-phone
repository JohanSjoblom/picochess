#!/usr/bin/env python3
import argparse
import json
import os
import re
import selectors
import socket
import subprocess
import sys
import time

SOCKET_DEFAULT = "/tmp/picochess-pairing.sock"
INI_DEFAULT = "/opt/picochess/picochess.ini"

MAC_RE = re.compile(r"Device\s+([0-9A-F:]{17})", re.IGNORECASE)
PASSKEY_RE = re.compile(r"Confirm passkey\s+(\d+)")


def read_ini(path: str) -> tuple[str | None, int | None, str | None, str | None]:
    pin = None
    timeout = None
    hotspot_ssid = None
    hotspot_pass = None
    try:
        with open(path, "r", encoding="utf-8") as handle:
            for raw in handle:
                line = raw.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                key, value = [part.strip() for part in line.split("=", 1)]
                if key == "bt-pair-pin" and value:
                    pin = value
                if key == "bt-pair-timeout" and value.isdigit():
                    timeout = int(value)
                if key == "hotspot-ssid" and value:
                    hotspot_ssid = value
                if key == "hotspot-pass" and value:
                    hotspot_pass = value
    except OSError:
        pass
    return pin, timeout, hotspot_ssid, hotspot_pass


def ipc_send(sock: socket.socket, payload: dict) -> None:
    data = json.dumps(payload, separators=(",", ":")) + "\n"
    sock.sendall(data.encode("utf-8"))


def show_text(sock: socket.socket, text: str) -> None:
    ipc_send(sock, {"action": "show_text", "text": text})


def send_bt(proc: subprocess.Popen, command: str) -> None:
    if proc.stdin is None:
        return
    proc.stdin.write(command + "\n")
    proc.stdin.flush()

def _get_wlan0_ip() -> str | None:
    ip_cmd = "/sbin/ip"
    if not os.path.exists(ip_cmd):
        return None
    try:
        result = subprocess.run([ip_cmd, "-4", "-o", "addr", "show", "dev", "wlan0"], capture_output=True, text=True, timeout=5)
    except Exception:
        return None
    if result.returncode != 0:
        return None
    for line in result.stdout.splitlines():
        parts = line.split()
        if "inet" in parts:
            idx = parts.index("inet")
            return parts[idx + 1].split("/")[0]
    return None

def _show_hotspot_or_ip(sock: socket.socket) -> None:
    wlan_ip = _get_wlan0_ip()
    if wlan_ip:
        show_text(sock, f"IP {wlan_ip}")
        return
    show_text(sock, "PAN FAILED")
    time.sleep(2)
    show_text(sock, "WIFI HOTSPOT")

def _try_hotspot_connect(ssid: str, password: str | None) -> bool:
    nmcli = "/usr/bin/nmcli"
    if not os.path.exists(nmcli):
        return False
    cmd = [nmcli, "dev", "wifi", "connect", ssid]
    if password:
        cmd += ["password", password]
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=20)
    return result.returncode == 0

def _bt_info(btctl_path: str, mac: str) -> tuple[bool, bool]:
    try:
        result = subprocess.run([btctl_path, "info", mac], capture_output=True, text=True, timeout=5)
    except Exception:
        return False, False
    if result.returncode != 0:
        return False, False
    output = result.stdout
    paired = "Paired: yes" in output
    connected = "Connected: yes" in output
    return paired, connected


def _resolve_paired_mac(btctl_path: str, current_mac: str | None) -> str | None:
    candidates = []
    if current_mac:
        candidates.append(current_mac)
    try:
        with open("/tmp/picochess-last-bt-mac", "r", encoding="utf-8") as handle:
            value = handle.read().strip()
            if value and value not in candidates:
                candidates.append(value)
    except OSError:
        pass
    if not candidates:
        try:
            result = subprocess.run([btctl_path, "devices", "Paired"], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    parts = line.strip().split()
                    if len(parts) >= 2 and parts[0] == "Device":
                        mac = parts[1]
                        if mac not in candidates:
                            candidates.append(mac)
        except Exception:
            pass
    for mac in candidates:
        paired, _ = _bt_info(btctl_path, mac)
        if paired:
            return mac
    return None


def main() -> int:
    parser = argparse.ArgumentParser(description="Pair an Android phone via bluetoothctl and show prompts on Picochess.")
    parser.add_argument("--timeout", type=int, default=None, help="Pairing timeout in seconds")
    parser.add_argument("--pin", type=str, default=None, help="Default PIN code if requested")
    parser.add_argument("--socket", type=str, default=SOCKET_DEFAULT, help="Pairing IPC socket path")
    parser.add_argument("--ini", type=str, default=INI_DEFAULT, help="Path to picochess.ini")
    parser.add_argument("--no-pan", action="store_true", help="Skip bt-pan-connect after pairing")
    parser.add_argument("--pan-timeout", type=int, default=40, help="Seconds to wait for PAN link")
    parser.add_argument("--pan-script", type=str, default="/opt/picochess/bt-pan-connect", help="PAN helper path")
    args = parser.parse_args()

    ini_pin, ini_timeout, hotspot_ssid, hotspot_pass = read_ini(args.ini)
    pin = args.pin if args.pin is not None else (ini_pin or "0000")
    timeout = args.timeout if args.timeout is not None else (ini_timeout or 40)
    timeout = max(5, min(timeout, 300))

    btctl_path = "/usr/bin/bluetoothctl"
    if not os.path.exists(btctl_path):
        print("bluetoothctl not found", file=sys.stderr)
        return 2

    ipc_sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        ipc_sock.connect(args.socket)
    except OSError as exc:
        print(f"failed to connect to pairing IPC ({args.socket}): {exc}", file=sys.stderr)
        return 2

    ipc_send(ipc_sock, {"action": "start", "timeout": timeout})
    show_text(ipc_sock, "BT PAIR: OPEN PHONE")

    proc = subprocess.Popen(
        [btctl_path],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=0,
    )

    if proc.stdout is None:
        print("failed to start bluetoothctl", file=sys.stderr)
        return 2

    os.set_blocking(proc.stdout.fileno(), False)

    send_bt(proc, "power on")
    send_bt(proc, f"discoverable-timeout {timeout}")
    send_bt(proc, "discoverable on")
    send_bt(proc, f"pairable-timeout {timeout}")
    send_bt(proc, "pairable on")
    send_bt(proc, "agent DisplayYesNo")
    send_bt(proc, "default-agent")

    selector = selectors.DefaultSelector()
    selector.register(proc.stdout, selectors.EVENT_READ, "bt")
    selector.register(ipc_sock, selectors.EVENT_READ, "ipc")

    bt_buffer = ""
    ipc_buffer = ""
    deadline = time.time() + timeout
    current_device = None
    awaiting_confirm = False
    confirmed_passkey = None
    success = False
    failed = False
    stop_reason = None

    def handle_bt_line(line: str) -> None:
        nonlocal current_device, awaiting_confirm, confirmed_passkey, success, failed
        if not line:
            return
        match = MAC_RE.search(line)
        if match:
            current_device = match.group(1)
        if "Connected: yes" in line:
            success = True
        if "Enter PIN code" in line:
            show_text(ipc_sock, f"PIN {pin}")
            send_bt(proc, pin)
        if "Confirm passkey" in line:
            passkey_match = PASSKEY_RE.search(line)
            confirmed_passkey = passkey_match.group(1) if passkey_match else None
            awaiting_confirm = True
            if confirmed_passkey:
                show_text(ipc_sock, f"PAIR {confirmed_passkey}")
            show_text(ipc_sock, "BTN4 YES BTN0 NO")
        if "Pairing successful" in line or "Paired: yes" in line:
            success = True
        if "Failed to pair" in line or "AuthenticationFailed" in line or "AuthenticationCanceled" in line:
            failed = True

    def handle_ipc_line(line: str) -> None:
        nonlocal awaiting_confirm, success, failed, stop_reason
        if not line:
            return
        try:
            msg = json.loads(line)
        except json.JSONDecodeError:
            return
        if msg.get("event") == "button":
            button = int(msg.get("button", -1))
            if awaiting_confirm:
                if button == 4:
                    send_bt(proc, "yes")
                    awaiting_confirm = False
                    show_text(ipc_sock, "CONFIRM YES")
                elif button == 0:
                    send_bt(proc, "no")
                    awaiting_confirm = False
                    failed = True
                    stop_reason = "stopped"
            elif button == 0:
                failed = True
                stop_reason = "stopped"
        elif msg.get("event") == "cancel":
            show_text(ipc_sock, "PAIR STOPPED")
            failed = True
            stop_reason = "stopped"
        elif msg.get("event") == "timeout":
            failed = True
            stop_reason = "timeout"

    while time.time() < deadline and not success and not failed:
        for key, _ in selector.select(timeout=0.5):
            if key.data == "bt":
                try:
                    data = os.read(proc.stdout.fileno(), 4096)
                except BlockingIOError:
                    data = b""
                if not data:
                    continue
                bt_buffer += data.decode("utf-8", errors="ignore")
                while "\n" in bt_buffer:
                    line, bt_buffer = bt_buffer.split("\n", 1)
                    handle_bt_line(line.strip())
            elif key.data == "ipc":
                try:
                    data = ipc_sock.recv(4096)
                except OSError:
                    data = b""
                if not data:
                    failed = True
                    if stop_reason is None:
                        stop_reason = "ipc_lost"
                    break
                ipc_buffer += data.decode("utf-8", errors="ignore")
                while "\n" in ipc_buffer:
                    line, ipc_buffer = ipc_buffer.split("\n", 1)
                    handle_ipc_line(line.strip())
        if proc.poll() is not None:
            failed = True
            if stop_reason is None:
                stop_reason = "btctl_exit"
            break

    if not success and not failed:
        resolved = _resolve_paired_mac(btctl_path, current_device)
        if resolved:
            current_device = resolved
            success = True

    if success:
        if current_device:
            send_bt(proc, f"trust {current_device}")
            try:
                with open("/tmp/picochess-last-bt-mac", "w", encoding="utf-8") as handle:
                    handle.write(current_device)
            except OSError:
                pass
        show_text(ipc_sock, "PAIRED OK")
        if not args.no_pan:
            show_text(ipc_sock, "START TETHER")
            time.sleep(3)
            pan_script = args.pan_script
            if os.path.exists(pan_script) and os.access(pan_script, os.X_OK):
                try:
                    pan_proc = subprocess.run(
                        [pan_script, "--timeout", str(args.pan_timeout)],
                        capture_output=True,
                        text=True,
                        timeout=args.pan_timeout + 5,
                    )
                except subprocess.TimeoutExpired:
                    _show_hotspot_or_ip(ipc_sock)
                    if hotspot_ssid:
                        _try_hotspot_connect(hotspot_ssid, hotspot_pass)
                        _show_hotspot_or_ip(ipc_sock)
                    print("pair-phone: paired, PAN timed out")
                    ipc_send(ipc_sock, {"action": "stop", "reason": "paired"})
                    send_bt(proc, "quit")
                    ipc_sock.close()
                    return 6
                if pan_proc.returncode == 0:
                    ip_match = re.search(r"connected\\s+\\w+\\s+(\\d+\\.\\d+\\.\\d+\\.\\d+)", pan_proc.stdout)
                    if ip_match:
                        ip_addr = ip_match.group(1)
                        show_text(ipc_sock, "OPEN WEB")
                        show_text(ipc_sock, f"IP {ip_addr}")
                        ipc_send(ipc_sock, {"action": "stop", "reason": "paired"})
                        send_bt(proc, "quit")
                        ipc_sock.close()
                        print("pair-phone: paired and PAN connected")
                        return 0
                    _show_hotspot_or_ip(ipc_sock)
                    if hotspot_ssid:
                        _try_hotspot_connect(hotspot_ssid, hotspot_pass)
                        _show_hotspot_or_ip(ipc_sock)
                    print("pair-phone: paired, PAN IP missing")
                    ipc_send(ipc_sock, {"action": "stop", "reason": "paired"})
                    send_bt(proc, "quit")
                    ipc_sock.close()
                    return 6
                _show_hotspot_or_ip(ipc_sock)
                if hotspot_ssid:
                    _try_hotspot_connect(hotspot_ssid, hotspot_pass)
                    _show_hotspot_or_ip(ipc_sock)
                print("pair-phone: paired, PAN failed")
                ipc_send(ipc_sock, {"action": "stop", "reason": "paired"})
                send_bt(proc, "quit")
                ipc_sock.close()
                return 6
            _show_hotspot_or_ip(ipc_sock)
            if hotspot_ssid:
                _try_hotspot_connect(hotspot_ssid, hotspot_pass)
                _show_hotspot_or_ip(ipc_sock)
            print("pair-phone: paired, PAN helper missing")
            ipc_send(ipc_sock, {"action": "stop", "reason": "paired"})
            send_bt(proc, "quit")
            ipc_sock.close()
            return 6
        ipc_send(ipc_sock, {"action": "stop", "reason": "paired"})
        send_bt(proc, "quit")
        ipc_sock.close()
        print("pair-phone: paired successfully")
        return 0

    if stop_reason == "stopped":
        show_text(ipc_sock, "PAIR STOPPED")
        exit_code = 3
        summary = "stopped by user"
    elif time.time() >= deadline or stop_reason == "timeout":
        show_text(ipc_sock, "PAIR TIMEOUT")
        exit_code = 2
        summary = "timed out"
    elif stop_reason == "ipc_lost":
        exit_code = 4
        summary = "IPC lost"
    elif stop_reason == "btctl_exit":
        show_text(ipc_sock, "PAIR FAILED")
        exit_code = 5
        summary = "bluetoothctl exited"
    else:
        show_text(ipc_sock, "PAIR FAILED")
        exit_code = 1
        summary = "pairing failed"
    ipc_send(ipc_sock, {"action": "stop", "reason": "failed"})
    send_bt(proc, "quit")
    ipc_sock.close()
    print(f"pair-phone: {summary}")
    return exit_code


if __name__ == "__main__":
    raise SystemExit(main())
